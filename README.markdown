# Ретроспекция

Решете първите три задачи отново. Целта е да постигнете кратки и ясни решения, които да включват всичко, което сте научили след домашното. В решенията си сте допуснали някои грешки. Сега имате възможност да ги оправите. Имате на разположение всички чужди решения, включително и нашите.

Досега не сме видели решения, в които няма какво да се подобри. Включително и нашите. Ако разгледате десетина, ще ви дойдат идеи. Ще има какво да научите. Ще има какво да подобрите. Опитайте се да направите най-краткия и ясен код, на който сте способни. 

Новите ви решения ще съдържат подобрения над старите. Това са неща, които сте научили. Искаме списък с 20 такива — по 6-7 за всяка задача. Това могат да бъдат дребни работи, свързани с Ruby или по-общи, концептуални неща. Всяко едно трябва да бъде видимо подобрение спрямо предишното ви решение. Например, ако сте научили, че нещо може да стане с <code>inject()</code> вместо с <code>each</code>, трябва старото ви решение да бъде с <code>each</code>, докато новото - с <code>inject</code>.

Ако си мислите, че 20 неща са много — не се притеснявайте. Просто се опитайте да направите по седем подобрения на всяко от решенията си. Така стават 21.

## Форма на предаване

За да предадете това домашно, трябва да имате [GitHub account](https://github.com/fmi/ruby-retrospective-1). Клонирайте нашето хранилище и променете <code>.rb</code> файловете. Обърнете внимание, че има нови стилови изисквания към всяка от задачите. Можете да ги погледнете просто с:

    $ rake check

Забележете, че през GitHub ще предадете само кода. Научените уроци стават с добре познатата форма в сайта. Този път, вместо цяла ruby програма искаме една дефинирана константа, `REPOSITORY` и списък от неща в коментари. Например:

    REPOSITORY = 'http://github.com/skanev/ruby-retrospective-1'

    # Двадесет неща, които научих.
    #
    # 1. Монадите в Haskell са много широка абстракция. Приложими са на много места,
    #    но това ги прави трудни за научаване. Любимият ми пример е Maybe монадата,
    #    в която верига от операции връща Nothing, ако връзка от веригата върне
    #    Nothing.
    # 2. case клас (в Scala) е по-подходящ за промоция, от стандартен такъв. 
    # 3. Проверката за възраст може да се реализира по-добре с полиморфизъм, отколкото
    #    с case или if.

Разбира се, това е примерен текст. Искаме уроци за Ruby решенията ви, не разсъждения за други забавни езици.

Обърнете внимание, че кодът ви е публичен, но десетте научени неща не са. Не ги споделяйте нито в GitHub, нито във форумите, нито помежду си.

## Оценяване

За тази задача получавате от 1 до 6 точки. Колко точно зависи от 20те урока и доколко са приложени в решенията ви. Ако имате страхотни решения, но половината от нещата са несериозни, ще получите половината точки. Ако имате невероятни решения и нямате списък от научени неща, ще получите 0 точки.

Впрочем, минаващите тестове и стилистична проверка са задължителни. Ако <code>rake check</code> открие дори една грешка в стила или един неуспешен тест, получавате 0 точки. Без значение какво сте написали.

## Watchr

Може да пуснете <code>watchr</code> с:

    $ rake watch

Разгледайте си подробностите сами.

## Разни

* Чувствайте се свободни да добавяте коментари в решенията си, които да казват какво сте научили. Или пък да задават въпроси.
* Няма да ви оценяваме българския език, но епични нива на неграмотност ще се наказват с отнети точки.
* Чувствайте се свободни да дискутирате всичко във форумите. Този път кодът е публичен. Може да питате каквото искате: "Как да направя това по-добре?", "Това добра идея ли е?", "Не мога да преценя което от тези две неща е по-удачно".
